\chapter{ Аналитический раздел}
\label{cha:analysis}

Задача упорядочивания элементов имеет широкое применения в совершенно разных сферах: упорядочивание слов по алфавиту, ряда чисел или структур данных. Многие алгоритмы нуждаются в упорядоченных рядах чисел для продолжения вычислений.

Сортировка ряда чисел сводится к получению упорядоченнего ряда. Пусть задан ряд $\{5, 3, 2, 6, 1\}$, тогда результат сортировки будет $\{1, 2, 3, 5, 6\}$. Существует множество методов сортировки, которые позволяют получить упорядоченный массив чисел. Одними из таких алгоритмов являются: метод пузырька, метод слияния и метод простыми вставками.

\section{ Сортировка пузырьком}

Пусть дан массив $\{3, 2, 6, 7, 9, 4\}$. Дана задача отсортировать его по убыванию. При решении этой задачи, алгоритм пройдется несколько раз по этому массиву, каждый раз проходя все меньше количество элементов. Первый проход представлен в таблице \ref{table:bubble}.

\begin{table}
	\caption{Процесс обработки массива на первой итерации алгоритма пузырька}\label{table:bubble}
	\begin{center}
		\begin{tabular}{ccccc}
            \textbf{Нет обмена} & \textbf{2 $\leftrightarrow$ 6} & \textbf{2 $\leftrightarrow$ 7} & \textbf{2 $\leftrightarrow$ 9} & \textbf{2 $\leftrightarrow$ 4}\\
            4 & 4 & 4 & 4 & \textbf{2} \\
            9 & 9 & 9 & \textbf{2} & \textbf{4} \\
            7 & 7 & \textbf{2} & \textbf{9} & 9 \\
            6 & \textbf{2} & \textbf{7} & 7 & 7 \\
            \textbf{2} & \textbf{6} & 6 & 6 & 6 \\
            \textbf{3} & 3 & 3 & 3 & 3\\
		\end{tabular}
	\end{center}
\end{table}

Далее последний эллемент массива фиксируется и действия сортировки продолжаются, но уже не до последнего элемента массива, а до предпоследнего. Количество обрабатывающихся элементов на каждой итерации изменяется как $N=N-1$, где N изначально является длинной массива. Полный результат работы алгоритма на каждой итерации предеставлен в таблице.

\begin{table}
	\caption{Результат работы алгоритма пузырька на каждой итерации}\label{table:bubbleResult}
	\begin{center}
		\begin{tabular}{cccccc}
            4 & \textbf{2} & \textbf{2} & \textbf{2} & \textbf{2} & \textbf{2} \\
            9 & 4 & \textbf{3} & \textbf{3} & \textbf{3} & \textbf{3} \\
            7 & 9 & 4 & \textbf{4} & \textbf{4} & \textbf{4} \\
            6 & 7 & 9 & 9 & \textbf{6} & \textbf{6} \\
            2 & 6 & 7 & 7 & 9 & \textbf{7} \\
            3 & 3 & 6 & 6 & 7 & 9 \\
            \textbf{i=0} & \textbf{i=1} & \textbf{i=2} & \textbf{i=3} & \textbf{i=4} & \textbf{i=5}\\
		\end{tabular}
	\end{center}
\end{table}

\subsection{ Сложность алгоритма пузырька\cite{bib1}}
При первой итерации совершается n-1 сравнений, поэтому даже в наилучшем случае(массив и так упорядочен) совершается n-1 сравнений.

Рассматривая худший случий -- сортируемые элементы следуют в порядке, обратному требуемому. В этом случае цикл будет повторен n-1 раз. На превой итерации выполняется n-1 сравнений, на второй итерации n-2 сравнений, и т.д. На последней итерации будет выполнено 1 сравнение. Общее число сравнений в наихудшем случае равно:

\begin{equation}
    C_{max} = \sum_{i-1}^{n-1} i = \frac{(n-1)*n}{2} = \frac{n^2}{2}-\frac{n}{2}=O(n^2)
\end{equation}

Перестановка возникает, если порядок сравниваемых элементов противоположен требуемому (а в наихудшем случае -- всегда). Поскольку каждая перестановка содержит 3 пересылки, общее число пересылок:

\begin{equation}
    M_{max} = 3*C_{max} = O(n^2)
\end{equation}

Рассмастривая средний случай, надо учитывать, что появление прохода без перестановки равновероятно в любом из n-1 проходов. Пусть $C_i$ -- число сравнений, выполняемых на первых $i$ проходах. Тогда среднее число сравнений:

\begin{equation}
    C_{mid} = \frac{1}{(n-1)} \sum_{i=1}^{n-1} C_i
\end{equation}

Из анализа структуры цикла for получаем:

\begin{equation}
    C_i = \sum_{j=1}^{n-1} j = \sum_{j=1}^{n-1} j - \sum_{j=1}^{i} j = \frac{n*(n-1)}{2} - \frac{i*(i-1)}{2}
\label{eq:fin}
\end{equation}

Из \ref{eq:fin}

\begin{equation}
    C_{mid} = \frac{n^2}{3} - \frac{n}{6} = O(n^2)
\end{equation}

\section{ Сортировка простыми вставками}
В сортировке вставками последовательно обрабатываются отрезки массива, начиная с первого элемента и затем последовательно расширяя подмассив, вставляя на своё место очередной неотсортированный элемент.

Для вставки используется буферная область памяти, в которой хранится элемент, ещё не вставленный на своё место (так называемый ключевой элемент). В подмассиве, начиная с конца отрезка, перебираются элементы, которые сравниваются с ключевым. Если эти элементы больше ключевого, то они сдивгаются на одну позицию вправо, освобождая место для последующих элементов. Если в результате этого перебора попадается элемент, меньший или равный ключевому, то значит в текущую свободную ячейку можно вставить ключевой элемент.

\section{ Сортировка слиянием}
Это рекурсивный алгоритм, который постоянно разбивает список пополам. Если список пуст или состоит из одного элемента, то он отсортирован по определению (базовый случай). Если в списке больше, чем один элемент, мы разбиваем его и рекурсивно вызываем сортировку слиянием для каждой из половин. После того, как обе они уже отсортированы, выполняется основная операция, называемая слиянием. Слияние - это процесс комбинирования двух меньших сортированных списков в один новый, но тоже отсортированный.

Таким образом задача разбивается на подзадачи, которые в свою очередь рекурсивно доходят до базовых случаев. Предположим, что нужно отсортировать массив A. Подзадачей будет сортировка подраздела этого массива начиная с индекса p и заканчивая индексом r, обозначенного как A[p..r].

Если q -- точка на полпути между p и r, то подмассив A[p..r] можно разделить на A[p..q] и A[q+1,r]. Далее оба массива сортируются и если базовый случай не был достигнут, то повторяем те же действия для каждогои з подмассивов.

\subsection{ Сложность сортировки слиянием\cite{bib1}}
Данная сортировка всегда имеет сложность $O(n log n)$ это вытекает из уравнения \ref{eq:mergeTime}

\begin{equation}
    T(n) = T(\frac{n}{2}) + T(\frac{n}{2}) + O(n)
    \label{eq:mergeTime}
\end{equation}

$log n$ -- добавление узла в сбалансированное дерево.

\section{ Рассчет трудоемкости алгоритма}

Рассчет трудоемкости алгоритма опирается на модель вычисления, в которой нужно определить свод правил : оценка операций, циклов, стоимость перехода по условиям.

\subsection{Модель вычеслений}

Стоимость каждой операции из следующего множества будем считать 1:
\{+,-,*, /, \%, <, <=, !=, >=, >, =, :=, \&, ||, []\}

Стоимость условного перехода if-else -- 0 и будет учитывать лишь стоимость выражения условия.

Стоимость циклал будет рассчитываться следующим образом:

Пусть цикл задан так:
\begin{equation}
        for(i=0, i<N, i++) \{ body \}
\end{equation}
, где N -- количество итераций

Тогда
i=0, i<N -- операции, выполняемые перед началом выполнения тела цикла и их общая стоимость равна 2, 
i++, i<N -- операции, которые выполняются каждую итерацию(их стоимость в общем тоже равна 2)

\begin{equation}
    f_{for} = 2 + N*(2 + f_{body})
\end{equation}
