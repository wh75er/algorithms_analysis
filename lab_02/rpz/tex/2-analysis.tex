\chapter{ Аналитический раздел}
\label{cha:analysis}

Умножение матриц -- важная задача в разных областях, которая помогает рассчитать системы линейных уравнение, которые в свою очередь применяются в системах моделирования реального мира, 3D моделировании, в обработке и хранении информации. 

Задача по эффективной обработке матриц является актуальной и востребованной в наши дни. Первым шагом на пути к более быстрому по времени перемножении матриц стал алгоритм Винограда. Он представляет собой перемножение матриц с использованием скалярного произведения соответствующих строки и столбца исходных матриц.

Более подробное описание алгоритма: 

\section{ Алгоритм Винограда}

Пусть даны матрицы A[N*M] и B[M*K], тогда их результирующее произведение можно представить как матрицу C[N*K]. При умножении "в лоб" мы получаем много операций умножения, которые являются очень трудоемкими по сравнению со сложением:

\begin{equation}
    A * B = v_1*w_1 + v_2 * w_2 + v_3 * w_3 + ... + v_m * w_m
    \label{eq:basis}
\end{equation}

Но это выражение можно представить в другом виде, в котором хорошо будут видны элементы, которые возможно рассчитать заранее и использовать несколько раз. Рассмотрим на частном случае:
Пусть даны вектора $V = (v1, v2, v3, v4)$ и $W = (w1, w2, w3, w4)$. Произведение $V*W$ можно найти по формуле \ref{eq:basis}, которая представлена в общем виде, но можно записать так:

\begin{equation}
    V*W = (v_1 + w_2)*(v_2 + w_1) + (v_3 + w_4)*(v_4+w_3) - v_1 * v_2 - v_3 * v_4 - w_1 * w_2 - w_3 * w_4
    \label{eq:win}
\end{equation}

Кажется, что второе выражение задает больше работы, чем первое: вместо четырех умножений мы насчитываем их шесть, а вместо трех сложений - десять. Менее очевидно, что выражение в правой части последнего равенства допускает предварительную обработку: его части можно вычислить заранее и запомнить для каждой строки первой матрицы и для каждого столбца второй. 
Часть $- v_1 * v_2 - v_3 * v_4 - w_1 * w_2 - w_3 * w_4$ из выражения \ref{eq:win} вычислима заранее, что позволят нам избавиться от лишних трудоемких операций умножения.
 Таким образом, несмотря на то, что второе выражение требует вычисления большего количества операций, чем первое: вместо четырех умножений - шесть, а вместо трех сложений - десять, выражение в правой части последнего равенства допускает предварительную обработку: его части можно вычислить заранее и запомнить для каждой строки первой матрицы и для каждого столбца второй, что позволяет выполнять для каждого элемента лишь первые два умножения и последующие пять сложений, а также дополнительно два сложения.


\section{ Рассчет трудоемкости алгоритма}

Рассчет трудоемкости алгоритма опирается на модель вычисления, в которой нужно определить свод правил : оценка операций, циклов, стоимость перехода по условиям.

Модель вычеслений

Стоимость каждой операции из следующего множества будем считать 1:
\{+,-,*, /, \%, <, <=, !=, >=, >, =, :=, \&, ||, []\}

Стоимость условного перехода if-else -- 0 и будет учитывать лишь стоимость выражения условия.

Стоимость циклал будет рассчитываться следующим образом:

Пусть цикл задан так:
\begin{equation}
    for(i=0, i<N, i++)
\end{equation}
, где N -- количество итераций

Тогда
i=0, i<N -- операции, выполняемые перед началом выполнения тела цикла и их общая стоимость равна 2, 
i++, i<N -- операции, которые выполняются каждую итерацию(их стоимость в общем тоже равна 2)

\begin{equation}
    f_{for} = 2 + N*(2 + body)
\end{equation}
