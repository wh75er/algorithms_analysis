\chapter{ Аналитический раздел}
\label{cha:analysis}

Умножение матриц -- важная задача в разных областях, которая помогает рассчитать системы линейных уравнение, которые в свою очередь применяются в системах моделирования реального мира, 3D моделировании, в обработке и хранении информации. 

Задача по эффективной обработке матриц является актуальной и востребованной в наши дни. Первым шагом на пути к более быстрому по времени перемножении матриц стал алгоритм Винограда. Он представляет собой перемножение матриц с использованием скалярного произведения соответствующих строки и столбца исходных матриц.

\section{ Стандартный алгоритм перемножения матриц.}
Пусть даны 2 квадратные матрицы размерностью $[l * m]$ и $[m * n]$ соответсвенно.

$
A = 
\begin{Bmatrix}
	a_11& a_12& ...   a_1m \\
	a_21& a_22& ...   a_2m \\
	...\\
	a_l1& a_l2& ...   a_lm \\
\end{Bmatrix}
$

$
B = 
\begin{Bmatrix}
	b_11& b_12& ...   b_1n \\
	b_21& b_22& ...   b_2n \\
	...\\
	b_m1& b_m2& ...   b_mn \\
\end{Bmatrix}
$


Тогда результатом умножения будет матрица размерностью $[l * n]$ вида:


$
C = 
\begin{Bmatrix}
	c_11& c_12& ...   c_1n \\
	c_21& c_22& ...   c_2n \\
	...\\
	c_l1& c_l2& ...   c_ln \\
\end{Bmatrix}
$

$c_{ij} = \sum_{r=1}^m a_{ir} * b_{rj}$, где $(i = 1, 2, ... l; j = 1, 2, ... n)$.


Операция умножения двух матриц выполнима только в том случае, если число столбцов в первом сомножителе равно числу строк во втором; в этом случае говорят, что матрицы согласованы. В частности, умножение всегда выполнимо, если оба сомножителя — квадратные матрицы одного и того же порядка.

\section{ Алгоритм Винограда}

Пусть даны матрицы A[N*M] и B[M*K], тогда их результирующее произведение можно представить как матрицу C[N*K]. При перемножении матриц стандартным алгоритмом, мы получаем много операций умножения, которые являются очень трудоемкими по сравнению со сложением:

\begin{equation}
    A * B = v_1*w_1 + v_2 * w_2 + v_3 * w_3 + ... + v_m * w_m
    \label{eq:basis}
\end{equation}

Но это выражение можно представить в другом виде, в котором хорошо будут видны элементы, которые возможно рассчитать заранее и использовать несколько раз. Рассмотрим на частном случае:
Пусть даны вектора $V = (v1, v2, v3, v4)$ и $W = (w1, w2, w3, w4)$. Произведение $V*W$ можно найти по формуле \ref{eq:basis}, которая представлена в общем виде, но можно записать так:

\begin{equation}
    V*W = (v_1 + w_2)*(v_2 + w_1) + (v_3 + w_4)*(v_4+w_3) - v_1 * v_2 - v_3 * v_4 - w_1 * w_2 - w_3 * w_4
    \label{eq:win}
\end{equation}

Кажется, что второе выражение задает больше работы, чем первое: вместо четырех умножений мы насчитываем их шесть, а вместо трех сложений - десять. Менее очевидно, что выражение в правой части последнего равенства допускает предварительную обработку: его части можно вычислить заранее и запомнить для каждой строки первой матрицы и для каждого столбца второй. 
Часть $- v_1 * v_2 - v_3 * v_4 - w_1 * w_2 - w_3 * w_4$ из выражения \ref{eq:win} вычислима заранее, что позволят нам избавиться от лишних трудоемких операций умножения.
 Таким образом, несмотря на то, что второе выражение требует вычисления большего количества операций, чем первое: вместо четырех умножений - шесть, а вместо трех сложений - десять, выражение в правой части последнего равенства допускает предварительную обработку: его части можно вычислить заранее и запомнить для каждой строки первой матрицы и для каждого столбца второй, что позволяет выполнять для каждого элемента лишь первые два умножения и последующие пять сложений, а также дополнительно два сложения.


\section{ Рассчет трудоемкости алгоритма}

Рассчет трудоемкости алгоритма опирается на модель вычисления, в которой нужно определить свод правил : оценка операций, циклов, стоимость перехода по условиям.

\subsection{Модель вычеслений}

Стоимость каждой операции из следующего множества будем считать 1:
\{+,-,*, /, \%, <, <=, !=, >=, >, =, :=, \&, ||, []\}

Стоимость условного перехода if-else -- 0 и будет учитывать лишь стоимость выражения условия.

Стоимость циклал будет рассчитываться следующим образом:

Пусть цикл задан так:
\begin{equation}
        for(i=0, i<N, i++) \{ body \}
\end{equation}
, где N -- количество итераций

Тогда
i=0, i<N -- операции, выполняемые перед началом выполнения тела цикла и их общая стоимость равна 2, 
i++, i<N -- операции, которые выполняются каждую итерацию(их стоимость в общем тоже равна 2)

\begin{equation}
    f_{for} = 2 + N*(2 + f_{body})
\end{equation}
