\chapter{ Аналитический раздел}
\label{cha:analysis}

\section{ Описание алгоритмов}
Пусть даны 2 квадратные матрицы размерностью $[l * m]$ и $[m * n]$ соответственно.

\subsection{ Классический алгоритм перемножения матриц.}
Операция умножения двух матриц выполнима только в то случае, если число столбцов в первом сомножителе равно числу строк во втором; в этом случае говорят, что матрицы согласованы. В частности, умножение всегда выполнимо, если оба сомножителя -- квадратные матрицы одного и того же порядка.

\subsection{ Алгоритм умножения матриц Винограда.}
Если посмотреть на результат умножения двух матриц, то видно, что каждый элемент в нем представляет собой скалярное произведение соответствующих строки и столбца исходных матриц. Можно заметить также, что такое умножение допускает предварительную обработку, позволяющую часть работы выполнить заранее. Рассмотрим два вектора $V = (v_1, v_2, v_3, v_4)$ и $W = (w_1, w_2, w_3, w_4)$. Их скалярное произведение равно $(V*W) = (v_1+w_2)*(v_2+w_1)+(v_3+w_4)*(v_4+w_3) - v_1*v_2 - v_3*v_2 - v_3*v_4-w_1*w_2-w_3*w_4$. Кажется, что второе выражение задает больше работы, чем первое: вместо четырех умножений мы насчитываем их шесть, а вместо трех сложений - десять. Менее очевидно, что выражение в правой части последнего равенства допускает предварительную обработку: его части можно вычислить заранее и запомнить для каждой строки первой матрицы и для каждого столбца второй. Таким образом, несмотря на то, что второе выражение требует вычисления большего количества операций, чем первое: вместо четырех умножений - шесть, а вместо трех сложений - десять, выражение в правой части последнего равенства допускает предварительную обработку: его части можно вычислить заранее и запомнить для каждой строки первой матрицы и для каждого столбца второй, что позволяет выполнять для каждого элемента лишь первые два умножения и последующие пять сложений, а также дополнительно для сложения.

\subsection{ Распараллеливание задач на CPU}
Процессор является одной из главных частей компьютера, которая позволяет выполнять планирование и вычисления. Мобильные системы (телефоны, планшеты, ноутбуки) и большинство десктопов имеют один процессор. Рабочие станции и сервера иногда могут похвастаться двумя или больше процессорами на одной материнской плате. Поддержка нескольких центральных процессоров в одной системе требует многочисленных изменений в её дизайне. Как минимум, необходимо обеспечить их физическое подключение (предусмотреть несколько сокетов на материнской плате), решить вопросы идентификации процессоров , согласования доступов к памяти и доставки прерываний (контроллер прерываний должен уметь маршрутизировать прерывания на несколько процессоров) и, конечно же, поддержки со стороны операционной системы.

Если процессоров несколько, то каждый из них имеет собственный разъём на плате. У каждого из них при этом имеются полные независимые копии всех ресурсов, таких как регистры, исполняющие устройства, кэши. Делят они общую память — RAM. Память может подключаться к ним различными и довольно нетривиальными способами, но это отдельная история, выходящая за рамки этой статьи. Важно то, что при любом раскладе для исполняемых программ должна создаваться иллюзия однородной общей памяти, доступной со всех входящих в систему процессоров.

Как уже упоминалось выше, работа с несколькими процессам требует серьезных изменений в дизайне системы, работающей с ними. Но стоимость несколько процессоров весьма не маленькая и, к тому же, если стоимость переключений между ними слишком велика, весь смысл от параллелизма пропадает. Тогда люди начали задумывать о том как расположить несколько процессов максимально близко друг к другу, желательно на одном кристале. На помощь здесь приходят ядра. Эти ядра во всем идентичны друг другу, но работают независимо.

Ядра могут иметь общие кэши и другие ресурсы, что заметно ускоряет работу, т.к. сокращает задержки обмена данных между ядрами, особенно если они работают надо общей задачей.

В один момент была предстаавлена новая технология компанией Intel -- HyperThreading, идея которой заключалась в выполнении одной программы разными потоками. Потоки так же могут дели Кэши и память. В отличие от «настоящих» ядер, являющихся полными и независимыми копиями, в случае HT в одном процессоре дублируется лишь часть внутренних узлов, в первую очередь отвечающих за хранение архитектурного состояния — регистры. Исполнительные же узлы, ответственные за организацию и обработку данных, остаются в единственном числе, и в любой момент времени используются максимум одним из потоков.

Пусть (x, y, z), где x — это число процессоров, y — число ядер в каждом процессоре, а z — число гиперпотоков в каждом ядре. Тогда произведение p = xyz определяет число сущностей, именуемых логическими процессорами системы. Оно определяет полное число независимых контекстов прикладных процессов в системе с общей памятью, исполняющихся параллельно, которые учитывает операционная система.

